
																CRIAÇÃO DE UMA WEB API COMPLETA
													(Na qual a camada de banco e negócios já estão criadas)

	1) CRIANDO A SOLUÇÃO "APICompleta":

		1.1) Crie uma solução em branco chamada "APICompleta".

		1.2) Acesse as pastas desta solução a partir do "Windows Explorer" e dentro dela, crie uma pasta chamada "src", exemplo "APICompleta\src".

		1.3) Na raiz deste repositório você encontrará uma pasta: "Referências\APICompleta\", copie o conteúdo desta pasta (pasta: "DevIO.Business" e pasta: "DevIO.Data") para 
			dentro de "APICompleta\src", que você criou no passo anterior.

		1.4) Retorne ao VS e clique com o botão direito do mouse, sobre a solução e escolha: "Adicionar\Projeto existente...", navegue até 
			"APICompleta\src\DevIO.Business\DevIO.Business.csproj" e dê dois cliques sobre este projeto para adicionar o mesmo a solução.

		1.5) Repita o processo anterior até "APICompleta\src\DevIO.Data\DevIO.Data.csproj" e dê dois cliques sobre este projeto para adicionar o mesmo a solução.
	
		1.6) Clique com o botão direito do mouse sobre a solução e escolha: "Adicionar\Novo Projeto...".

		1.7) Escolha o tipo de projeto com "API Web do ASP.NET Core", clique em próximo.

		1.8) Chame este projeto de "DevIO.Api", e "APICompleta\src\" para ser salvo e clique em próximo.

		1.9) Sete as "Informações adicionais":

				Estrutura de Destino: "Atual"
				Tipo de Autenticação: "Nenhum"
				Configurar para HTTPS: "Sim"
				Habilitar o Docker: "Não"
				Habilitar o suporte a OpenAPI: Não

			Feito isto clique em criar.

	2) CONFIGURANDO OS PROJETOS E A SOLUÇÃO:

		2.1) Clique com o botão direito do mouse sobre "DevIO.Api" e escolha a opção: "Definir como projeto de inicialização".

		2.2) Em projeto "DevIO.Api", clique com o botão direito do mouse sobre "Dependências" e escolha a opção "Adicionar referência de projeto...".

			2.2.1) Na tela do "Gerenciador de Referências", flag o projeto "DevIO.Business" e o "DevIO.Data", em seguida clique em OK.

		2.3) Compile a aplicação para ver se não existem erros.

	3) Implementando DTOs (ViewModels):

		3.1) Crie uma pasta chamada "ViewModels" em "DevIO.Api" e dentro dela crie as models abaixo:

			3.1.1) FornecedorViewModel.cs

				using System;
				using System.Collections.Generic;
				using System.ComponentModel.DataAnnotations;

				namespace DevIO.Api.ViewModel
				{
					public class FornecedorViewModel
					{
						[Key] // Informa ao Scaffold que a propriedade Id é uma chave, para que o mesmo não tente gerar a mesma.
						public Guid Id { get; set; }

						[Required(ErrorMessage = "O campo {0} é obrigatório")]
						[StringLength(100, ErrorMessage = "O campo {0} precisa ter entre {2} e {1} caracteres", MinimumLength = 2)]
						public string Nome { get; set; }

						[Required(ErrorMessage = "O campo {0} é obrigatório")]
						[StringLength(14, ErrorMessage = "O campo {0} precisa ter entre {2} e {1} caracteres", MinimumLength = 11)]
						public string Documento { get; set; }

						public int TipoFornecedor { get; set; }

						public EnderecoViewModel Endereco { get; set; }

						public bool Ativo { get; set; }

						public IEnumerable<ProdutoViewModel> Produtos { get; set; }
					}
				}

			3.1.2) EnderecoViewModel.cs

				using System;
				using System.ComponentModel.DataAnnotations;

				namespace DevIO.Api.ViewModel
				{
					public class EnderecoViewModel
					{
						[Key]
						public Guid Id { get; set; }

						[Required(ErrorMessage = "O campo {0} é obrigatório")]
						[StringLength(200, ErrorMessage = "O campo {0} precisa ter entre {2} e {1} caracteres", MinimumLength = 2)]
						public string Logradouro { get; set; }

						[Required(ErrorMessage = "O campo {0} é obrigatório")]
						[StringLength(50, ErrorMessage = "O campo {0} precisa ter entre {2} e {1} caracteres", MinimumLength = 1)]
						public string Numero { get; set; }

						public string Complemento { get; set; }

						[Required(ErrorMessage = "O campo {0} é obrigatório")]
						[StringLength(100, ErrorMessage = "O campo {0} precisa ter entre {2} e {1} caracteres", MinimumLength = 2)]
						public string Bairro { get; set; }

						[Required(ErrorMessage = "O campo {0} é obrigatório")]
						[StringLength(8, ErrorMessage = "O campo {0} precisa ter entre {2} e {1} caracteres", MinimumLength = 2)]
						public string Cep { get; set; }

						[Required(ErrorMessage = "O campo {0} é obrigatório")]
						[StringLength(100, ErrorMessage = "O campo {0} precisa ter entre {2} e {1} caracteres", MinimumLength = 2)]
						public string Cidade { get; set; }

						[Required(ErrorMessage = "O campo {0} é obrigatório")]
						[StringLength(50, ErrorMessage = "O campo {0} precisa ter entre {2} e {1} caracteres", MinimumLength = 2)]
						public String Estado { get; set; }

						public Guid FornecedorId { get; set; }
					}
				}
			
			3.1.3) ProdutoViewModel.cs

				using System;
				using System.ComponentModel.DataAnnotations;
				
				namespace DevIO.Api.ViewModel
				{
					public class ProdutoViewModel
					{
						[Key]
						public Guid Id { get; set; }

						[Required(ErrorMessage = "O campo {0} é obrigatório")]
						public Guid FornecedorId { get; set; }

						[Required(ErrorMessage = "O campo {0} é obrigatório")]
						[StringLength(200, ErrorMessage = "O campo {0} precisa ter entre {2} e {1} caracteres", MinimumLength = 2)]
						public string Nome { get; set; }

						[Required(ErrorMessage = "O campo {0} é obrigatório")]
						[StringLength(1000, ErrorMessage = "O campo {0} precisa ter entre {2} e {1} caracteres", MinimumLength = 2)]
						public string Descricao { get; set; }

						public string ImagemUpload { get; set; }

						public string Imagem { get; set; }

						[Required(ErrorMessage = "O campo {0} é obrigatório")]
						public string Valor { get; set; }

						[ScaffoldColumn(false)]
						public DateTime DataCadastro { get; set; }

						public bool Ativo { get; set; }

						[ScaffoldColumn(false)]
						public string NomeFornecdor { get; set; }
					}
				}

	4) SETUP - CONTROLLERS E STARTUP (Criando as controllers)

		4.1) Abra a pasta "Controllers" e renomeie o arquivo "WeatherForecastController.cs" para "MainController.cs".

		4.1.2) Altere o seu contéudo pelo código abaixo:

			using Microsoft.AspNetCore.Mvc;

			namespace DevIO.Api.Controllers
			{
				[ApiController]
				public abstract class MainController : ControllerBase
				{
					// Validações das notificações de erro

					// Validação de Modelstate

					// validação da operação de negócios
        
				}
			}

		4.2) Crie uma Controller chamada: "FornecedoresController", e insira o código abaixo:

			using DevIO.Api.Controllers;
			using DevIO.Api.ViewModel;
			using DevIO.Business.Intefaces;
			using Microsoft.AspNetCore.Mvc;
			using System.Collections.Generic;
			using System.Threading.Tasks;

			namespace DevIO.Api.Controllers
			{
				[Route("api/[controller]")]
				public class FornecedoresController : MainController
				{
					// declara o objeto para a inversão de dependência
					private readonly IFornecedorRepository _fornecedorRepository;

					// cria o construtor para a inversão de dependência
					public FornecedoresController(IFornecedorRepository fornecedorRepository)
					{
						_fornecedorRepository = fornecedorRepository;
					}

					// Retorna uma lista de fornecedores
					public async Task<ActionResult<IEnumerable<FornecedorViewModel>>> ObterTodos()
					{

						var fornecedor = await _fornecedorRepository.ObterTodos();

						return Ok();
					}
				}
			}

		4.3) Adicionando o mapeamento.
		
			4.2.3) No "Console do gerenciador de Pacotes) digite: "install-package AutoMapper.Extensions.Microsoft.DependencyInjection" e clique e aperte enter,
				para fazer a instalação da extensão da inversão de dependência do automaper.

			4.2.3) Abra o arquivo "Startup.cs" e dentro do método "ConfigureServices", adicione a extensão do método Mapper, conforme o código abaixo:

				// Adiciona a extensão do método AutoMapper
	            services.AddAutoMapper(typeof(Startup));

		4.4) Criando uma lista de: Dê - Para.

			4.4.1) Em "DevIO.Api", crie uma nova pasta chamada "Configuration".

			4.4.2) Crie uma classe chamada "AutomapperConfig.cs" dentro da pasta "Configurations" e insira o código abaixo:

				using AutoMapper;
				using DevIO.Api.ViewModel;
				using DevIO.Business.Models;

				namespace DevIO.Api.Configurations
				{
					// Essa classe herda a classe Profile, pertencente ao Automapper
					public class AutomapperConfig : Profile
					{
						// Contrutor da configuração de mapeamento
						public AutomapperConfig()
						{
							// Faz o mapeamento das classes
							CreateMap<Fornecedor, FornecedorViewModel>().ReverseMap(); // Caso não seja necessário usar parametros, utilize o ".ReversMap()".
							CreateMap<Endereco, EnderecoViewModel>().ReverseMap();
							CreateMap<Produto, ProdutoViewModel>().ReverseMap();
						}
					}
				}

		4.5) Abra a Controller "FornecedoresController", e altere pelo código abaixo:

			using AutoMapper;
			using DevIO.Api.ViewModel;
			using DevIO.Business.Intefaces;
			using Microsoft.AspNetCore.Mvc;
			using System.Collections.Generic;
			using System.Threading.Tasks;

			namespace DevIO.Api.Controllers
			{
				[Route("api/[controller]")]
				public class FornecedoresController : MainController
				{
					// declara o objeto para a inversão de dependência
					private readonly IFornecedorService _fornecedorService;
					private readonly IFornecedorRepository _fornecedorRepository;
					private readonly IMapper _mapper;

					// cria o construtor para a inversão de dependência
					public FornecedoresController(IFornecedorService fornecedorService, IFornecedorRepository fornecedorRepository, IMapper mapper)
					{
						_fornecedorService = fornecedorService;
						_fornecedorRepository = fornecedorRepository;
						_mapper = mapper;
					}

					// Retorna uma lista de fornecedores
					public async Task<ActionResult<IEnumerable<FornecedorViewModel>>> ObterTodos()
					{
						// Seta um mapeamento (_mapper.Map) de uma lista (IEnumerable<FornecedorViewModel>), recebida de (await _fornecedorRepository.ObterTodos()).
						var fornecedor = _mapper.Map<IEnumerable<FornecedorViewModel>>(await _fornecedorRepository.ObterTodos()); // Lembre-se: recebeu uma lista, mapea uma lista

						// Retorna um código 200 com o ActionResult de fornecedor
						return Ok(fornecedor); // 
					}
				}
			}
				
		4.6) Resolvendo problemas de dependências:

			4.6.1) Na pasta "Configurations" crie uma classe chamada: "DependencyInjectionConfig.cs" e cole o código abaixo dentro dela:

				using DevIO.Business.Intefaces;
				using DevIO.Data.Context;
				using DevIO.Data.Repository;
				using Microsoft.Extensions.DependencyInjection;

				namespace DevIO.Api.Configurations
				{
					public static class DependencyInjectionConfig
					{
						// Método de extensão para o IServiceCollection
						public static IServiceCollection ResolveDependencies(this IServiceCollection services)
						{
							// Adiciona o contexto ao escopo
							services.AddScoped<MeuDbContext>();

							// Adiciona o repositório do fornecedor escopo
							services.AddScoped<IFornecedorRepository, FornecedorRepository>();

							// retorna todos os serviços
							return services;
						}

					}
				}

			4.6.1) Abra a classe "Startup.cs" e adicione o código abaixo, no final do método "ConfigureServices":

				// Resolve os problemas de dependência
				services.ResolveDependencies();

		4.7) Configurando o MeuDbContext

			4.7.1) Abra o arquivo "appsettings.json" da pasta "Raiz" da aplicação e adicione o código:

				Logo abaixo dê: "AllowedHosts": "*", não esqueça de adicionar um virgula em ("*",). 

				  "ConnectionStrings": {
						"DefaultConnection": "Server=ALEDESKTOP;Database=MinhaApiCore2;Trusted_Connection=True;MultipleActiveResultSets=true"
					}

			4.7.2) Abra a classe "Startup" na raiz da aplicação e adicione o código abaxio dentro do método "ConfigureServices" logo no começo.

				// Inicia o "MeuDbContext"
				services.AddDbContext<MeuDbContext>(optionsAction: options =>
				{
					options.UseSqlServer(Configuration.GetConnectionString(name: "DefaultConnection"));
				});

			4.7.3) Caso o VS fique com frescura, vá até o "Console do Gerenciador de Pacotes" e instale os packages abaixo para no projeto que você está trabalhando:

				Install-Package Microsoft.EntityFrameworkCore
				Install-Package Microsoft.EntityFrameworkCore.SqlServer
				Install-Package Microsoft.EntityFrameworkCore.Tools

				Install-Package Microsoft.EntityFrameworkCore -Version 2.2.6
				Install-Package Microsoft.EntityFrameworkCore.SqlServer -Version 2.2.6
				Install-Package Microsoft.EntityFrameworkCore.Tools -Version 2.2.6

			4.7.4) No "Console do Gerenciador de Pacotes", altere o projeto padrão para o "DevIO.Data" e execute o comando abaixo para o EntityFramwork atualizar o banco.

				update-database -verbose

			4.7.5) Teste a aplicação:

				A mesma subirá com erro, então informe o link abaixo:

				https://localhost:44338/api/fornecedores

				Caso a pagina abra com "[]" ok, está funcionando corretamente.

		5) MODELANDO A CONTROLLER DE FORNECEDORES

			5.1) Abra o arquivo "FornecedoresController.cs" na pasta "Controller" e adicione o método abaixo, no final do arquivo para obter o fornecedor por Id.

				[HttpGet("{id:guid")] // Criando a rota (Verbo) para o fornecedor por id.
				// Retorna o fornecedor por Id
				public async Task<ActionResult<FornecedorViewModel>> ObterPorId(Guid id)
				{
					// Seta a variavel com o retorno "ObterFornecedorProdutosEndereco", através do mapemento entre a "FornecedorViewModel"
					//  e o repositório do "fornecedor _fornecedorRepository".
					var fornecedor = _mapper.Map<FornecedorViewModel>(await _fornecedorRepository.ObterFornecedorProdutosEndereco(id));

					// Verifica se o fornecedor foi preenchido
					if (fornecedor == null) return NotFound(); // Não encontrado

					// Retorna um código 200 com o ActionResult de fornecedor
					return Ok(fornecedor); // 
				}

			5.2) Dentro da classe "FornecedoresController.cs", no final da pagina, adicione o código abaixo, para economizar código na criação de código.

				// Encapsulando os dados do fornecedor dentro de um método
				public async Task<FornecedorViewModel> ObterFornecedorProdutosEndereco(Guid id)
				{
					// Retorna os dados do fornecedor, produtos e endereços através do mapeamento entre "FornecedorViewModel" e o "_fornecedorRepository"
					return _mapper.Map<FornecedorViewModel>(await _fornecedorRepository.ObterFornecedorProdutosEndereco(id));
				}

				[HttpGet("{id:guid")] // Criando a rota (Verbo) para o fornecedor por id.
				// Retornando o fornecedor po Id
				public async Task<ActionResult<FornecedorViewModel>> ObterPorIdEncapsulado(Guid id)
				{
					// Obtem os dados do fornedor através do encapsulamento no método "ObterFornecedorProdutosEndereco".
					var fornecedor = await ObterFornecedorProdutosEndereco(id);

					// Verifica se o fornecedor foi preenchido
					if (fornecedor == null) return NotFound(); // Não encontrado

					// retorna o fornecedor
					return Ok(fornecedor);
				}

			5.3) Dentro da classe "FornecedoresController.cs", no final da pagina, adicione o código abaixo para adicionar um fornecedor:

				[HttpPost]
				// método adicionar fornecedor
				public async Task<ActionResult<FornecedorViewModel>> Adicionar(FornecedorViewModel fornecedorViewModel)
				{
					// Verifica se existe erro no modelo recebido
					if (!ModelState.IsValid) return BadRequest(); // Com erro

					// Mapeaia(converte) o modelo recebido para a entidade fornecedor
					var fornecedor = _mapper.Map<Fornecedor>(fornecedorViewModel);

					// Envia o fornecedor para a camada de negócio para ser validado as regras de negócio, ao invé de mandar gravar diretamente no banco.
					var result = await _fornecedorService.Adicionar(fornecedor);

					// Retorna um erro encontrado no FornecedorServiço para a validação da entidade.
					if (!result) return BadRequest();

					// Retorna 
					return Ok(fornecedor);
				}

			5.4) Dentro da classe "FornecedoresController.cs", no final da pagina, adicione o código abaixo para atualizar um fornecedor:

				[HttpPut("{id:guid}")]
				// método atualizar fornecedor
				public async Task<ActionResult<FornecedorViewModel>> Atualizar(Guid id, FornecedorViewModel fornecedorViewModel)
				{
					// Verifica se o Id do fornecedor é válido
					if (id != fornecedorViewModel.Id) return BadRequest(); // Com erro

					// Verifica se existe erro no modelo recebido
					if (!ModelState.IsValid) return BadRequest(); // Com erro

					// Mapeaia(converte) o modelo recebido para a entidade fornecedor
					var fornecedor = _mapper.Map<Fornecedor>(fornecedorViewModel);

					// Envia o fornecedor para a camada de negócio para ser validado as regras de negócio, ao invés de mandar gravar diretamente no banco.
					var result = await _fornecedorService.Atualizar(fornecedor);

					// Retorna um erro encontrado no FornecedorServiço para a validação da entidade.
					if (!result) return BadRequest();

					// Retorna 
					return Ok(fornecedor);
				}

			5.5) Dentro da classe "FornecedoresController.cs", no final da pagina, adicione o código abaixo para excluir um fornecedor:

				[HttpDelete("{id:guid}")]
				public async Task<ActionResult<FornecedorViewModel>> Excluir(Guid id)
				{
					// seta o fornecedor
					var fornecedor = await ObterFornecedorEndereco(id);

					// Verifica se o fornecedor foi encontrado
					if (!ModelState.IsValid) return NotFound(); // Não encontrado

					// Remove o fornecedor.
					var result = await _fornecedorService.Remover(id);

					// Verifica se ocorreu algum erro com a remoção do fornecedor através dos serviços da camada de negócio.
					if (!result) return BadRequest();

					// retorna
					return Ok(fornecedor);
				}

				// Encapsulando os dados do fornecedor dentro de um método
				public async Task<FornecedorViewModel> ObterFornecedorEndereco(Guid id)
				{
					// Retorna os dados do fornecedor, produtos e endereços através do mapeamento entre "FornecedorViewModel" e o "_fornecedorRepository"
					return _mapper.Map<FornecedorViewModel>(await _fornecedorRepository.ObterFornecedorEndereco(id));
				}

